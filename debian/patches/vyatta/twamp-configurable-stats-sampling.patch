From: Duncan Eastoe <deastoe@vyatta.att-mail.com>
Date: Mon, 12 Jun 2017 12:17:04 +0100
Subject: Sample stats during TWAMP sessions

A stats sample can now be generated by sending SIGUSR1 to the main
client process. A new option, -l, can also be used to generate
samples at an interval during a session.
---
 owamp/api.c      | 286 ++++++++++++++++++++++++++++++++++-
 owamp/endpoint.c |  71 +++++++--
 owamp/owamp.h    |  61 +++++++-
 owamp/owampP.h   |   1 +
 owamp/stats.c    |  11 +-
 owping/owping.c  | 443 +++++++++++++++++++++++++++++++++++++++++++++++--------
 owping/owpingP.h |   1 +
 7 files changed, 790 insertions(+), 84 deletions(-)

diff --git a/owamp/api.c b/owamp/api.c
index 253d3bf..b3b1816 100644
--- a/owamp/api.c
+++ b/owamp/api.c
@@ -3135,6 +3135,8 @@ OWPWriteDataRecord(
  *
  * Description:
  *         Write a single data record described by rec to file fp.
+ *         If flk is not NULL then it will be obtained before writing,
+ *         and released before returning.
  *
  * In Args:
  *
@@ -3146,12 +3148,14 @@ OWPWriteDataRecord(
  */
 OWPBoolean
 OWPWriteTWDataRecord(
-        OWPContext  ctx,
-        FILE        *fp,
+        OWPContext    ctx,
+        FILE          *fp,
+        struct flock  *flk,
         OWPTWDataRec  *rec
         )
 {
-    char    buf[_OWP_DATAREC_TWV3_SIZE];
+    char         buf[_OWP_DATAREC_TWV3_SIZE];
+    OWPBoolean   ret_val;
 
     if(!_OWPEncodeTWDataRecord(buf,rec)){
         OWPError(ctx,OWPErrFATAL,OWPErrUNKNOWN,
@@ -3159,18 +3163,292 @@ OWPWriteTWDataRecord(
         return False;
     }
 
+    /*
+     * Lock file before writing
+     */
+    if(flk){
+        flk->l_type = F_WRLCK;
+        if(fcntl(fileno(fp),F_SETLKW,flk) < 0){
+            OWPError(ctx,OWPErrFATAL,errno,
+                    "OWPWriteTWDataRecord: Unable to lock file: %M");
+            return False;
+        }
+    }
+
+    ret_val = False;
+
     /*
      * write data record
      */
     if(fwrite(buf,1,_OWP_DATAREC_TWV3_SIZE,fp) != _OWP_DATAREC_TWV3_SIZE){
         OWPError(ctx,OWPErrFATAL,errno,
-                "OWPWriteDataRecord: fwrite(): %M");
+                "OWPWriteTWDataRecord: fwrite(): %M");
+        goto finish;
+    }
+
+    /*
+     * Flush to ensure that stats can be calculated on all records
+     * that have been written
+     */
+    if(fflush(fp)){
+        OWPError(ctx,OWPErrWARNING,errno,
+                "OWPWriteTWDataRecord: fflush(): %M");
+    }
+
+    ret_val = True;
+
+finish:
+    /*
+     * Unlock file
+     */
+    if(flk){
+        flk->l_type = F_UNLCK;
+        if(fcntl(fileno(fp),F_SETLKW,flk) < 0){
+            OWPError(ctx,OWPErrFATAL,errno,
+                    "OWPWriteTWDataRecord: Unable to unlock file: %M");
+            return False;
+        }
+    }
+
+    return ret_val;
+}
+
+/*
+ * Function:        OWPReadTWDataRecord
+ *
+ * Description:
+ *         Read a single data record from file fp at offset into rec.
+ *
+ * In Args:
+ *
+ * Out Args:
+ *
+ * Scope:
+ * Returns:
+ * Side Effect:
+ */
+OWPBoolean
+OWPReadTWDataRecord(
+        OWPContext    ctx,
+        FILE          *fp,
+        off_t         offset,
+        uint32_t      file_version,
+        OWPTWDataRec  *rec
+        )
+{
+    size_t       len_rec;
+    char         buf[_OWP_DATAREC_TWV3_SIZE];
+
+    switch(file_version){
+        case _OWP_VERSION_TWOWAY|3:
+            len_rec = _OWP_DATAREC_TWV3_SIZE;
+            break;
+        default:
+            OWPError(ctx,OWPErrFATAL,EINVAL,
+                    "OWPReadTWDataRecord: Invalid file version (%d)",
+                    file_version);
+            return False;
+    }
+
+    if(fseek(fp,offset,SEEK_SET) != 0){
+        OWPError(ctx,OWPErrFATAL,errno,
+                "OWPReadTWDataRecord: fseek(): %M");
+        return False;
+    }
+
+    if(fread(buf,len_rec,1,fp) < 1){
+        if(ferror(fp)){
+            OWPError(ctx,OWPErrFATAL,errno,
+                    "fread(): STREAM ERROR: offset=%" PRIuPTR,ftello(fp));
+        }
+        else if(feof(fp)){
+            OWPError(ctx,OWPErrFATAL,errno,
+                    "fread(): EOF: offset=%" PRIu64,ftello(fp));
+        }
+        return False;
+    }
+
+    if(!_OWPDecodeTWDataRecord(file_version,rec,buf)){
+        errno = EFTYPE;
+        OWPError(ctx,OWPErrFATAL,errno,
+                "OWPReadTWDataRecord: Invalid Data Record: %M");
+        return False;
+    }
+
+    return True;
+}
+
+/*
+ * Function:        OWPGetTWSeqRange
+ *
+ * Description:
+ *         Get the first and last send sequence numbers in file fp,
+ *         starting from offset.
+ *
+ * In Args:
+ *
+ * Out Args:
+ *
+ * Scope:
+ * Returns:
+ * Side Effect:
+ */
+OWPBoolean
+OWPGetTWSeqRange(
+        OWPContext          ctx,
+        FILE                *fp,
+        off_t               offset,
+        off_t               fileend,
+        OWPSessionHeaderRec *hdr,
+        uint32_t            *first,
+        uint32_t            *last
+        )
+{
+        OWPTWDataRec rec;
+        uint32_t     temp;
+
+        if(offset > (fileend - hdr->rec_size)){
+            OWPError(ctx,OWPErrFATAL,OWPErrUNKNOWN,
+                "OWPGetTWSeqRange: Offset is past the last record");
+            return False;
+        }
+
+        /*
+         * Retrieve the send sequence number for the first record in
+         * the file
+         */
+        if(!OWPReadTWDataRecord(ctx,fp,offset,hdr->version,&rec)){
+            return False;
+        }
+        *first = rec.sent.seq_no;
+
+        /*
+         * Retrieve the send sequence number for the final record in
+         * the file
+         */
+        if(!OWPReadTWDataRecord(ctx,fp,(fileend - hdr->rec_size),
+                                hdr->version,&rec)){
+            return False;
+        }
+        *last = rec.sent.seq_no;
+
+        if(*first >= hdr->test_spec.npackets){
+            OWPError(ctx,OWPErrFATAL,OWPErrUNKNOWN,
+                "OWPGetTWSeqRange: Invalid starting seq num %u", *first);
+            return False;
+        }
+        if(*last >= hdr->test_spec.npackets){
+            OWPError(ctx,OWPErrFATAL,OWPErrUNKNOWN,
+                "OWPGetTWSeqRange: Invalid ending seq num %u", *last);
+            return False;
+        }
+
+        /*
+         * If the first sequence number is larger than the last sequence
+         * number then there has been some kind of re-ordering or duplication.
+         *
+         * Swap the first and last values around.
+         */
+        if(*first > *last){
+            temp = *first;
+            *first = *last;
+            *last = temp;
+        }
+
+        return True;
+}
+
+/*
+ * Function:        OWPGetFileSize
+ *
+ * Description:
+ *         Get the size of the file fp.
+ *
+ * In Args:
+ *
+ * Out Args:
+ *
+ * Scope:
+ * Returns:
+ * Side Effect:
+ */
+OWPBoolean
+OWPGetFileSize(
+        OWPContext          ctx,
+        FILE                *fp,
+        off_t               *file_size,
+        OWPSessionHeaderRec *hdr
+        )
+{
+    if(fseeko(fp,0,SEEK_END) != 0){
+        OWPError(ctx,OWPErrFATAL,errno,"OWPGetFileSize: fseeko(): %M");
+        return False;
+    }
+    if((*file_size = ftello(fp)) < 0){
+        OWPError(ctx,OWPErrFATAL,errno,"OWPGetFileSize: ftello(): %M");
         return False;
     }
 
+    /*
+     * Adjust fileend if some record is incomplete. This is most likely
+     * the last, if not, an error will be raised later anyway.
+     */
+    if(hdr){
+        *file_size -= ((*file_size - hdr->oset_datarecs) % hdr->rec_size);
+    }
+
     return True;
 }
 
+/*
+ * Function:        OWPFileRecordOffsetCheck
+ *
+ * Description:
+ *         Check that the record offset falls within the file size given.
+ *         The offset will be advanced to the start of the data records
+ *         if it is not already there.
+ *
+ * In Args:
+ *
+ * Out Args:
+ *
+ * Scope:
+ * Returns:
+ * Side Effect:
+ */
+int
+OWPFileRecordOffsetCheck(
+        OWPContext          ctx,
+        off_t               file_size,
+        off_t               *offset,
+        OWPSessionHeaderRec *hdr
+        )
+{
+    /*
+     * Ensure that the offset points to at least the start of the
+     * data records
+     */
+    if(*offset < hdr->oset_datarecs){
+        *offset = hdr->oset_datarecs;
+    }
+
+    /*
+     * If the file is empty or the offset is at the end of the file
+     * then there is nothing to do
+     */
+    if(file_size == 0 || *offset == file_size){
+        return 0;
+    }
+
+    if(*offset > file_size){
+        OWPError(ctx,OWPErrFATAL,OWPErrUNKNOWN,
+                "OWPFileOffsetCheck: offset (%u) larger than file (%u)",
+                 *offset,file_size);
+        return -1;
+    }
+
+    return 1;
+}
 
 /*
  * Function:        OWPReadDataHeader
diff --git a/owamp/endpoint.c b/owamp/endpoint.c
index 7ff2c4a..eebd8d9 100644
--- a/owamp/endpoint.c
+++ b/owamp/endpoint.c
@@ -738,6 +738,15 @@ success:
             goto error;
         }
 
+        /*
+         * Setup file lock for two-way client
+         */
+        if(ep->twoway){
+            ep->datafile_flk.l_start = 0;
+            ep->datafile_flk.l_len = 0;
+            ep->datafile_flk.l_whence = SEEK_SET;
+        }
+
         /*
          * Determine "optimal" file buffer size. To allow "Fetch"
          * clients to access ongoing tests - we define "optimal" as
@@ -1996,8 +2005,8 @@ flush_lost(
                 lostrec.reflected.send = lostrec.sent.recv;
                 lostrec.reflected.recv = lostrec.sent.recv;
 
-                if( !OWPWriteTWDataRecord(ep->cntrl->ctx,
-                            ep->datafile,&lostrec)){
+                if( !OWPWriteTWDataRecord(ep->cntrl->ctx,ep->datafile,
+                            &ep->datafile_flk,&lostrec)){
                     OWPError(ep->cntrl->ctx,OWPErrFATAL,
                             OWPErrUNKNOWN,
                             "OWPWriteTWDataRecord()");
@@ -3091,8 +3100,10 @@ run_tw_test(
     ssize_t         resp_len;
     OWPSessionHeaderRec hdr;
     OWPTWDataRec    twdatarec;
-    OWPLostPacket node;
-    int flush_rc;
+    OWPLostPacket   node;
+    int             flush_rc;
+    uint8_t         exit_status;
+    uint8_t         header_finished_status;
 
     /*
      * Get pointer to lsaddr used for listening.
@@ -3126,6 +3137,16 @@ run_tw_test(
     memcpy(&hdr.addr_sender,lsaddr,lsaddrlen);
     memcpy(&hdr.addr_receiver,rsaddr,rsaddrlen);
 
+    /*
+     * Lock the data file
+     */
+    ep->datafile_flk.l_type = F_WRLCK;
+    if(fcntl(fileno(ep->datafile),F_SETLKW,&ep->datafile_flk) < 0){
+        OWPError(ep->cntrl->ctx,OWPErrFATAL,errno,
+                 "run_tw_test: Unable to lock datafile: %M");
+        exit(OWP_CNTRL_FAILURE);
+    }
+
     /*
      * Write the file header.
      */
@@ -3135,6 +3156,21 @@ run_tw_test(
         exit(OWP_CNTRL_FAILURE);
     }
 
+    if(fflush(ep->datafile)){
+        OWPError(ep->cntrl->ctx,OWPErrWARNING,errno,
+                 "run_tw_test: fflush(): %M");
+    }
+
+    /*
+     * Unlock the data file
+     */
+    ep->datafile_flk.l_type = F_UNLCK;
+    if(fcntl(fileno(ep->datafile),F_SETLKW,&ep->datafile_flk) < 0){
+        OWPError(ep->cntrl->ctx,OWPErrFATAL,errno,
+                 "run_tw_test: Unable to unlock file: %M");
+        exit(OWP_CNTRL_FAILURE);
+    }
+
     /*
      * Initialize pointers to various positions in the packet buffer,
      * for data that changes for each packet. Also set zero padding.
@@ -3632,7 +3668,7 @@ RECEIVE:
             }
 
             if( !OWPWriteTWDataRecord(ep->cntrl->ctx,ep->datafile,
-                                      &twdatarec)){
+                                      &ep->datafile_flk,&twdatarec)){
                 OWPError(ep->cntrl->ctx,OWPErrFATAL,OWPErrUNKNOWN,
                          "OWPWriteTWDataRecord()");
                 goto finish_sender;
@@ -3716,17 +3752,30 @@ finish_sender:
                 "run_tw_test: Exiting from signal");
 
 error:
-        _OWPWriteDataHeaderFinished(ep->cntrl->ctx,ep->datafile,OWP_SESSION_FINISHED_ERROR,0);
-        fclose(ep->datafile);
-        ep->datafile = NULL;
-        exit(OWP_CNTRL_FAILURE);
+        header_finished_status = OWP_SESSION_FINISHED_ERROR;
+        exit_status = OWP_CNTRL_FAILURE;
+    }
+    else{
+        header_finished_status = OWP_SESSION_FINISHED_NORMAL;
+        exit_status = OWP_CNTRL_ACCEPT;
     }
 
-    _OWPWriteDataHeaderFinished(ep->cntrl->ctx,ep->datafile,OWP_SESSION_FINISHED_NORMAL,0);
+    /*
+     * Lock on data file to write final header
+     * This will be released at fclose(...)
+     */
+    ep->datafile_flk.l_type = F_WRLCK;
+    if(fcntl(fileno(ep->datafile),F_SETLKW,&ep->datafile_flk) < 0){
+        OWPError(ep->cntrl->ctx,OWPErrFATAL,errno,
+                "run_tw_test: Unable to lock file: %M");
+        goto finish_sender;
+    }
+
+    _OWPWriteDataHeaderFinished(ep->cntrl->ctx,ep->datafile,header_finished_status,0);
     fclose(ep->datafile);
     ep->datafile = NULL;
 
-    exit(OWP_CNTRL_ACCEPT);
+    exit(exit_status);
 }
 
 
diff --git a/owamp/owamp.h b/owamp/owamp.h
index a95f1c0..feb2df2 100644
--- a/owamp/owamp.h
+++ b/owamp/owamp.h
@@ -1430,11 +1430,68 @@ OWPWriteDataRecord(
 
 extern OWPBoolean
 OWPWriteTWDataRecord(
-        OWPContext  ctx,
-        FILE        *fp,
+        OWPContext   ctx,
+        FILE         *fp,
+        struct flock *flk,
         OWPTWDataRec *rec
         );
 
+extern OWPBoolean
+OWPReadTWDataRecord(
+        OWPContext    ctx,
+        FILE          *fp,
+        off_t         offset,
+        uint32_t      file_version,
+        OWPTWDataRec  *rec
+        );
+
+/*
+ * This function returns the sequence number at offset in *first, and
+ * the last sequence number before fileend in *last. True is returned
+ * on success and False is returned on failure.
+ */
+extern OWPBoolean
+OWPGetTWSeqRange(
+        OWPContext          ctx,
+        FILE                *fp,
+        off_t               offset,
+        off_t               fileend,
+        OWPSessionHeaderRec *hdr,
+        uint32_t            *first,
+        uint32_t            *last
+        );
+
+/*
+ * Get the size, in bytes, of the file. False is returned on failure.
+ * If hdr is not NULL then the size given is guaranteed to be at the
+ * end of a record.
+ */
+extern OWPBoolean
+OWPGetFileSize(
+        OWPContext          ctx,
+        FILE                *fp,
+        off_t               *file_size,
+        OWPSessionHeaderRec *hdr
+        );
+
+/*
+ * Checks that the given record offset falls within the file size given.
+ * If the offset is less than the start of the records it will be advanced
+ * up to that point.
+ *
+ * Returns:
+ *      -1      failure
+ *      0       The file is empty or the offset is at the end of the file
+ *      1       The offset falls before the end of the file
+ */
+extern int
+OWPFileRecordOffsetCheck(
+        OWPContext          ctx,
+        off_t               file_size,
+        off_t               *offset,
+        OWPSessionHeaderRec *hdr
+        );
+
 /*
  * This (type of) function is used by Fetch-Client to process
  * data records.
diff --git a/owamp/owampP.h b/owamp/owampP.h
index 79dea60..92a0501 100644
--- a/owamp/owampP.h
+++ b/owamp/owampP.h
@@ -325,6 +325,7 @@ typedef struct OWPEndpointRec{
     char                fname[PATH_MAX];
     FILE                *userfile;          /* from _OWPOpenFile */
     FILE                *datafile;          /* correct buffering */
+    struct flock        datafile_flk;
     char                *fbuff;
 
     struct timespec     start;
diff --git a/owamp/stats.c b/owamp/stats.c
index 2d355da..8069845 100644
--- a/owamp/stats.c
+++ b/owamp/stats.c
@@ -1658,14 +1658,9 @@ OWPStatsParse(
         fileend = stats->hdr->oset_skiprecs;
     }
     else{
-        if(fseeko(stats->fp,0,SEEK_END) != 0){
-            OWPError(stats->ctx,OWPErrFATAL,errno,
-                    "OWPStatsParse: fseeko(): %M");
-            return False;
-        }
-        if((fileend = ftello(stats->fp)) < 0){
-            OWPError(stats->ctx,OWPErrFATAL,errno,
-                    "OWPStatsParse: ftello(): %M");
+        if(!OWPGetFileSize(stats->ctx,stats->fp,&fileend,stats->hdr)){
+            OWPError(stats->ctx,OWPErrFATAL,OWPErrUNKNOWN,
+                    "OWPStatsParse: OWPGetFileSize failed");
             return False;
         }
     }
diff --git a/owping/owping.c b/owping/owping.c
index 33bdc70..df77dd8 100644
--- a/owping/owping.c
+++ b/owping/owping.c
@@ -50,6 +50,7 @@ static char         tmpdir[PATH_MAX+1];
 static uint8_t      *pfbuff = NULL;
 static size_t       pfbuff_len = 0;
 static int          owp_intr = 0;
+static int          owp_usr1 = 0;
 
 static char         dirpath[PATH_MAX];
 static uint32_t     file_oset,tstamp_oset,ext_oset;
@@ -131,21 +132,24 @@ print_output_args(
         void
         )
 {
-    fprintf(stderr, "%s\n\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n",
-            "              [Output Args]",
-            "   -a alpha       report an additional percentile level for the delays",
-            "   -b bucketwidth bin size for histogram calculations",
-            "   -M             print machine (perl) readable summary",
-            "   -n units       \'n\',\'u\',\'m\', or \'s\'",
+    fprintf(stderr,
+            "              [Output Args]\n"
+            "   -a alpha       report an additional percentile level for the delays\n"
+            "   -b bucketwidth bin size for histogram calculations\n"
+#ifdef TWAMP
+            "   -l interval    sample statistics at intervals during the session (seconds)\n"
+#endif
+            "   -M             print machine (perl) readable summary\n"
+            "   -n units       \'n\',\'u\',\'m\', or \'s\'\n"
             "   -N count       number of test packets (to summarize per sub-session)\n"
-            "   -Q             run the test and exit without reporting statistics",
+            "   -Q             run the test and exit without reporting statistics\n"
 #ifdef TWAMP
-            "   -R             print RAW data: \"SSEQ STIME SS SERR SRTIME SRS SRERR STTL RSEQ RSTIME RSS RSERR RTIME RS RERR RTTL\\n\"",
+            "   -R             print RAW data: \"SSEQ STIME SS SERR SRTIME SRS SRERR STTL RSEQ RSTIME RSS RSERR RTIME RS RERR RTTL\\n\"\n"
 #else
-            "   -R             print RAW data: \"SEQNO STIME SS SERR RTIME RS RERR TTL\\n\"",
+            "   -R             print RAW data: \"SEQNO STIME SS SERR RTIME RS RERR TTL\\n\"\n"
 #endif
-            "   -v[N]          print out individual delays. You can supply an optional N here to limit the print to the first N packets",
-            "   -U             Adds UNIX timestamps when printing individual delays"
+            "   -v[N]          print out individual delays. You can supply an optional N here to limit the print to the first N packets\n"
+            "   -U             Adds UNIX timestamps when printing individual delays\n"
            );
 }
 
@@ -334,9 +338,10 @@ printrawTW(
  * Does statistical output parsing.
  */
 int
-do_stats(
-        OWPContext    ctx,
+do_stats_range(
+        OWPContext  ctx,
         FILE        *fp,
+        off_t       *offset,
         char        *from,
         char        *to,
         OWPTestSpec *tspec
@@ -347,22 +352,72 @@ do_stats(
     uint32_t            num_rec;
     uint32_t            num_sum;
     uint32_t            sum;
+    uint32_t            first;
+    uint32_t            last;
+    uint32_t            range;
+    off_t               temp_offset;
+    off_t               fileend;
     char                tfname[PATH_MAX];
     char                sfname[PATH_MAX];
     char                startname[PATH_MAX];
     char                endname[PATH_MAX];
     FILE                *tfp;
     char                *ext;
+    int                 rc;
+
+    /*
+     * If an offset is given then check that the file is not completely
+     * empty before continuing
+     */
+    if(offset){
+        if(!OWPGetFileSize(ctx,fp,&fileend,NULL)){
+             return -1;
+        }
+
+        if(fileend == 0){
+            return 0;
+        }
+    }
 
     if(!(num_rec = OWPReadDataHeader(ctx,fp,&hdr)) && !hdr.header){
         I2ErrLog(eh, "OWPReadDataHeader: Invalid file?");
         return -1;
     }
 
+    /*
+     * When an offset is given retrieve the file size again, now we have
+     * a header, and check the offset's validity against the data file
+     */
+    if(offset){
+        if(!OWPGetFileSize(ctx,fp,&fileend,&hdr)){
+             return -1;
+        }
+
+        rc = OWPFileRecordOffsetCheck(ctx,fileend,offset,&hdr);
+        if(rc <= 0){
+            return rc;
+        }
+    }
+
     /*
      * If raw data is requested, no summary information is needed.
      */
     if(ping_ctx.opt.raw){
+        if(offset){
+            /*
+             * Seek up to the offset
+             */
+            if(fseeko(fp,*offset,SEEK_SET) != 0){
+                I2ErrLog(eh,"do_stats_range: fseeko(): %M");
+                return -1;
+            }
+
+            /*
+             * Re-calculate the number of records
+             */
+             num_rec = (fileend - *offset) / hdr.rec_size;
+        }
+
 #ifdef TWAMP
         if(OWPParseTWRecords(ctx,fp,num_rec,hdr.version,printrawTW,stdout)
                 < OWPErrWARNING){
@@ -376,6 +431,10 @@ do_stats(
             return -1;
         }
 #endif
+        if(offset){
+            *offset = fileend;
+        }
+
         return 0;
     }
 
@@ -408,16 +467,52 @@ do_stats(
         hdr.test_spec.npackets = tspec->npackets;
 #endif
 
+    /*
+     * Calculate the range to perform stats over based on the
+     * provided data file offset
+     */
+    if(offset){
+#ifndef TWAMP
+        I2ErrLog(eh,"do_stats_range: offset only supported for TWAMP");
+        OWPStatsFree(stats);
+        return -1;
+#else
+        if(!OWPGetTWSeqRange(ctx,fp,*offset,fileend,&hdr,&first,&last)){
+            I2ErrLog(eh,"do_stats_range: failed to get seq num range");
+            OWPStatsFree(stats);
+            return -1;
+        }
+
+        /*
+         * Since stats are actually performed up to last-1 we
+         * need to advance last
+         */
+        last++;
+
+        /*
+         * Number of packets in this summary
+         */
+        range = last-first;
+#endif
+    }
+    else{
+        first = 0;
+        last = ~0;
+        temp_offset = 0;
+        offset = &temp_offset;
+        range = hdr.test_spec.npackets;
+    }
+
     /*
      * How many summaries?
      */
     if(!ping_ctx.opt.numBucketPackets ||
-            (ping_ctx.opt.numBucketPackets >= hdr.test_spec.npackets)){
+            (ping_ctx.opt.numBucketPackets >= range)){
         num_sum = 0;
     }
     else{
-        num_sum = hdr.test_spec.npackets / ping_ctx.opt.numBucketPackets;
-        if(hdr.test_spec.npackets % ping_ctx.opt.numBucketPackets){
+        num_sum = range / ping_ctx.opt.numBucketPackets;
+        if(range % ping_ctx.opt.numBucketPackets){
             num_sum++;
         }
     }
@@ -442,7 +537,7 @@ do_stats(
             tfp = stdout;
         }
 
-        if( !OWPStatsParse(stats,(ping_ctx.opt.records?tfp:NULL),0,0,~0)){
+        if( !OWPStatsParse(stats,(ping_ctx.opt.records?tfp:NULL),*offset,first,last)){
             I2ErrLog(eh,"OWPStatsParse: failed");
             OWPStatsFree(stats);
             if(ping_ctx.opt.printfiles){
@@ -491,13 +586,14 @@ do_stats(
         }
     }
     else{
+        stats->next_oset = *offset;
         for(sum=0;sum<num_sum;sum++){
             uint32_t    begin,end;
 
-            begin = ping_ctx.opt.numBucketPackets * sum;
-            end = ping_ctx.opt.numBucketPackets * (sum+1);
-            if(end > hdr.test_spec.npackets){
-                end = ~0;
+            begin = first + (ping_ctx.opt.numBucketPackets * sum);
+            end = first + (ping_ctx.opt.numBucketPackets * (sum+1));
+            if(end > hdr.test_spec.npackets || end > last){
+                end = last;
             }
 
             /*
@@ -564,9 +660,30 @@ do_stats(
 
     OWPStatsFree(stats);
 
+    *offset = fileend;
+
+    /*
+     * Ensure we have seeked to the end of the file
+     */
+    if(fseek(fp,0,SEEK_END) != 0){
+        I2ErrLog(eh,"do_stats_range: fseek(): %M");
+        return -1;
+    }
+
     return 0;
 }
 
+int
+do_stats(
+        OWPContext  ctx,
+        FILE        *fp,
+        char        *from,
+        char        *to,
+        OWPTestSpec *tspec
+        )
+{
+    return do_stats_range(ctx,fp,NULL,from,to,tspec);
+}
 
 static FILE *
 tfile(
@@ -1182,6 +1299,9 @@ signal_catch(
         )
 {
     switch(signo){
+        case SIGUSR1:
+            owp_usr1 = 1;
+            break;
         case SIGINT:
         case SIGTERM:
         case SIGHUP:
@@ -1245,7 +1365,7 @@ main(
     static char         *out_opts = "a:b:d:Mn:N:pQRv::U";
     static char         *gen_opts = "h";
 #ifdef TWAMP
-    static char         *tw_opts = "Z";
+    static char         *tw_opts = "Zl:";
 #else
     static char         *ow_opts = "ftT:";
 #endif
@@ -1319,6 +1439,7 @@ main(
     ping_ctx.opt.numPackets = 100;
     ping_ctx.opt.lossThreshold = 0.0;
     ping_ctx.opt.delayStart = 0.0;
+    ping_ctx.opt.statsDumpInterval = 0;
     ping_ctx.opt.percentiles = NULL;
     ping_ctx.opt.padding = OWP_PADDING_UNSET;
     ping_ctx.mean_wait = (float)0.1;
@@ -1562,6 +1683,19 @@ main(
                     exit(1);
                 }
                 break;
+#ifdef TWAMP
+            case 'l':
+                errno = 0;
+                ping_ctx.opt.statsDumpInterval = strtoul(optarg, &endptr, 10);
+                check_errno_erange(progname, NULL);
+                if ((optarg[0] == '-') || (*endptr != '\0') ||
+                        (ping_ctx.opt.statsDumpInterval <= 0)){
+                    usage(progname,
+                            "Invalid \'-l\' value. Positive integer greater than 0 expected");
+                    exit(1);
+                }
+                break;
+#endif
             case 'd':
                 if (!(ping_ctx.opt.savedir = strdup(optarg))) {
                     I2ErrLog(eh,"malloc: %M");
@@ -1666,6 +1800,13 @@ main(
         ping_ctx.opt.quiet = True;
     }
 
+#ifdef TWAMP
+    if(ping_ctx.opt.statsDumpInterval && ping_ctx.opt.quiet && !ping_ctx.opt.raw){
+        I2ErrLog(eh,"Ignoring \'-l\', \'-Q\' set");
+        ping_ctx.opt.statsDumpInterval = 0;
+    }
+#endif
+
     if(ping_ctx.opt.records && ping_ctx.opt.quiet){
         I2ErrLog(eh,"Ignoring \'-v\', \'-Q\' set");
         ping_ctx.opt.records = False;
@@ -1845,6 +1986,39 @@ main(
             exit(1);
         }
 
+        /*
+         * Get "local" and "remote" names for pretty printing
+         * if we need them.
+         */
+        local = remote = NULL;
+        if(!ping_ctx.opt.quiet){
+            I2Addr    laddr;
+            size_t    lsize;
+
+            /*
+             * First determine local address.
+             */
+            laddr = I2AddrByLocalSockFD(eh,OWPControlFD(ping_ctx.cntrl), False);
+
+            lsize = sizeof(localbuf);
+            I2AddrNodeName(laddr,localbuf,&lsize);
+            if(lsize > 0){
+                local = localbuf;
+            }
+            I2AddrFree(laddr);
+
+            /*
+             * Now determine remote address.
+             */
+            laddr = I2AddrByNode(eh,ping_ctx.remote_test);
+            lsize = sizeof(remotebuf);
+            I2AddrNodeName(laddr,remotebuf,&lsize);
+            if(lsize > 0){
+                remote = remotebuf;
+            }
+            I2AddrFree(laddr);
+        }
+
         rtt_bound = OWPGetRTTBound(ping_ctx.cntrl);
         /*
          * Set the loss threshold to 2 seconds longer then the
@@ -2044,11 +2218,193 @@ main(
             endtime -= OWPNum64ToDouble(curr_time.owptime);
 
             fprintf(stdout,
-                    "Approximately %.1f seconds until results available\n",
-                    endtime);
+                    "Approximately %.1f seconds until",endtime);
+
+            if(ping_ctx.opt.statsDumpInterval > 0){
+                fprintf(stdout," end of test\n");
+            }
+            else{
+                fprintf(stdout," results available\n");
+            }
         }
         if(owp_intr) exit(2);
 
+#ifdef TWAMP
+        OWPNum64            stats_dump_interval;
+        OWPNum64            wake;
+        OWPNum64            *wakep;
+        OWPTimeStamp        currstamp;
+        sigset_t            sigs,osigs;
+        struct flock        flk;
+        off_t               *offsets;
+        OWPAcceptType       stopsess_acceptval;
+
+        offsets = calloc(ping_ctx.opt.sessionCount, sizeof(off_t));
+        if(!offsets){
+            I2ErrLog(eh,"calloc(): %M");
+            exit(1);
+        }
+
+        /*
+         * Stats dump schedule set up
+         */
+        if(ping_ctx.opt.statsDumpInterval > 0){
+            stats_dump_interval = OWPULongToNum64(ping_ctx.opt.statsDumpInterval);
+            wakep = &wake;
+        }
+        else{
+            wakep = NULL;
+        }
+
+        /*
+         * Setup file lock
+         */
+        memset(&flk,0,sizeof(flk));
+        flk.l_start = 0;
+        flk.l_len = 0;
+        flk.l_whence = SEEK_SET;
+
+        sigemptyset(&sigs);
+        sigaddset(&sigs,SIGUSR1);
+
+        /*
+         * Set SIGUSR1 handler
+         */
+        if(sigaction(SIGUSR1,&setact,NULL) != 0){
+            I2ErrLog(eh,"sigaction(): %M");
+            exit(1);
+        }
+
+        if(owp_intr && !owp_usr1) exit(2);
+        do{
+            /*
+             * Set next wake for stats dump
+             */
+            if(wakep){
+                if(!OWPGetTimeOfDay(ctx,&currstamp)){
+                    I2ErrLog(eh,"OWPGetTimeOfDay(): %M");
+                    break;
+                }
+                wake = OWPNum64Add(currstamp.owptime,stats_dump_interval);
+            }
+
+            ch = OWPStopSessionsWait(ping_ctx.cntrl,wakep,&owp_intr,&acceptval,&err);
+
+            /*
+             * SIGUSR1 also causes the interrupt signal flag to be set,
+             * so if the SIGUSR1 flag is set, reset the interrupt flag
+             */
+            if(owp_usr1){
+                owp_intr = 0;
+            }
+
+            /*
+             * An error occurred while monitoring the control
+             * connection.
+             */
+            if(ch < 0){
+                break;
+            }
+
+            /*
+             * If scheduled dumps weren't requested, then don't do stats
+             * until all the sessions have ended, unless it was requested
+             * by SIGUSR1 or a termination or a session ended in error.
+             *
+             * This ensures that stats aren't generated until all tests
+             * are finished.
+             */
+            if(!wakep && ch > 0 && !owp_usr1 && !owp_intr && !acceptval){
+                continue;
+            }
+
+            owp_usr1 = 0;
+
+            if(!ping_ctx.opt.quiet || ping_ctx.opt.raw){
+                /*
+                 * Block delivery of SIGUSR1 during stats generation
+                 */
+                if(sigprocmask(SIG_BLOCK,&sigs,&osigs) != 0){
+                    I2ErrLog(eh,"sigprocmask(): %M");
+                    break;
+                }
+
+                /*
+                 * Perform stats
+                 */
+                for(sess_idx = 0; sess_idx < ping_ctx.opt.sessionCount; sess_idx++){
+                    if(fromfp[sess_idx]){
+                        /*
+                         * Lock the datafile, preventing the send/recv
+                         * process from modifying the file while we
+                         * do stats
+                         */
+                        flk.l_type = F_WRLCK;
+                        if(fcntl(fileno(fromfp[sess_idx]),F_SETLKW,&flk) < 0){
+                            I2ErrLog(eh,"Unable to lock file for session %u: %M",
+                                     sess_idx);
+
+                            /*
+                             * Delivery of SIGUSR1 is still blocked
+                             */
+                            goto twamp_finish;
+                        }
+
+                        if(do_stats_range(ctx,fromfp[sess_idx],&offsets[sess_idx],
+                                          local,remote,&tspec)){
+                            I2ErrLog(eh,"do_stats_range failed!");
+                        }
+
+                        /*
+                         * Unlock datafile
+                         */
+                        flk.l_type = F_UNLCK;
+                        if(fcntl(fileno(fromfp[sess_idx]),F_SETLKW,&flk) < 0){
+                            I2ErrLog(eh,"Unable to unlock file for session %u: %M",
+                                     sess_idx);
+                            /*
+                             * Delivery of SIGUSR1 is still blocked
+                             */
+                            goto twamp_finish;
+                        }
+                    }
+                }
+
+                /*
+                 * Unblock delivery of SIGUSR1
+                 */
+                if(sigprocmask(SIG_SETMASK,&osigs,NULL) != 0){
+                    I2ErrLog(eh,"sigprocmask(): %M");
+                    break;
+                }
+            }
+
+        /*
+         * Loop while there are active sessions, no sessions have
+         * ended in error and there hasn't been an early termination
+         * request (signal)
+         */
+        }while(ch > 0 && !acceptval && !owp_intr);
+
+twamp_finish:
+        /*
+         * Send StopSessions message if it hasn't already been sent
+         */
+        if(ch > 0){
+            (void)OWPStopSessions(ping_ctx.cntrl,&owp_intr,&stopsess_acceptval);
+        }
+
+        free(offsets);
+
+        if((ch < 0) || (acceptval != OWP_CNTRL_ACCEPT) ||
+           (stopsess_acceptval != OWP_CNTRL_ACCEPT)){
+            I2ErrLog(eh, "Test session(s) Failed...");
+            if(ping_ctx.opt.save_from_test){
+                (void)unlink(ping_ctx.opt.save_from_test);
+            }
+            exit(1);
+        }
+#else
         /*
          * If ch == 2, it is possible to continue parsing partial data.
          */
@@ -2074,40 +2430,6 @@ main(
         }
         if(owp_intr > 1) exit(2);
 
-        /*
-         * Get "local" and "remote" names for pretty printing
-         * if we need them.
-         */
-        local = remote = NULL;
-        if(!ping_ctx.opt.quiet){
-            I2Addr    laddr;
-            size_t    lsize;
-
-            /*
-             * First determine local address.
-             */
-            laddr = I2AddrByLocalSockFD(eh,OWPControlFD(ping_ctx.cntrl), False);
-
-            lsize = sizeof(localbuf);
-            I2AddrNodeName(laddr,localbuf,&lsize);
-            if(lsize > 0){
-                local = localbuf;
-            }
-            I2AddrFree(laddr);
-
-            /*
-             * Now determine remote address.
-             */
-            laddr = I2AddrByNode(eh,ping_ctx.remote_test);
-            lsize = sizeof(remotebuf);
-            I2AddrNodeName(laddr,remotebuf,&lsize);
-            if(lsize > 0){
-                remote = remotebuf;
-            }
-            I2AddrFree(laddr);
-        }
-
-#ifndef TWAMP
         if(ping_ctx.opt.to && (ping_ctx.opt.save_to_test ||
                     !ping_ctx.opt.quiet || ping_ctx.opt.raw)){
             FILE    *tofp;
@@ -2129,7 +2451,6 @@ main(
                 }
             }
         }
-#endif
 
         if(owp_intr > 1) exit(2);
 
@@ -2145,11 +2466,15 @@ main(
                     I2ErrLog(eh, "do_stats(\"from\" session)");
                 }
             }
+        }
+#endif
 
+        for (sess_idx = 0; sess_idx < ping_ctx.opt.sessionCount; sess_idx++){
             if(fromfp[sess_idx] && fclose(fromfp[sess_idx])){
                 I2ErrLog(eh,"close(): %M");
             }
         }
+
         free(fromfp);
         free(tosid);
 
diff --git a/owping/owpingP.h b/owping/owpingP.h
index 565af8e..471b9a7 100644
--- a/owping/owpingP.h
+++ b/owping/owpingP.h
@@ -77,6 +77,7 @@ typedef    struct {
         char            units;              /* -n */
         uint32_t        numBucketPackets;   /* -N */
         float           bucket_width;       /* -b */
+        uint32_t        statsDumpInterval;  /* -l */
 
         char            *savedir;           /* -d */
         I2Boolean       printfiles;         /* -p */
